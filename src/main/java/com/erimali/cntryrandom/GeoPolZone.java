package com.erimali.cntryrandom;

import javafx.geometry.Point2D;
import javafx.scene.paint.Color;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public abstract class GeoPolZone {
    private static double seaLevel = 0.0;
    // Generated randomly
    protected Point2D mainPoint;
    // Generated by Voronoi algorithms
    protected List<Point2D> boundary;
    // Generated by Perlin Noise
    protected double elevation;

    private static int ZONE_IDS = 0;
    private int zoneId = ZONE_IDS++;


    // For future game logic

    protected int provId;
    protected String name;
    protected List<RandProvince> neighProvs = new ArrayList<>();
    protected List<RandWaterBody> neighWaters = new ArrayList<>();

    public static double getSeaLevel() {
        return seaLevel;
    }


    public boolean aboveSeaLevel() {
        return elevation >= seaLevel;
    }

    public abstract Color getColor();

    // Shoelace Formula for polygons
    public double area() {
        int n = boundary.size();
        if (n < 3) {
            return 0; // A polygon needs at least 3 points
        }

        double area = 0.0;
        for (int i = 0; i < n; i++) {
            Point2D p1 = boundary.get(i);
            Point2D p2 = boundary.get((i + 1) % n); // Wrap around to the first point
            area += (p1.getX() * p2.getY() - p2.getX() * p1.getY());
        }
        return Math.abs(area) / 2.0;
    }


    public abstract String getName();

    public void setName(String name) {
        this.name = name;
    }

    public int getZoneId() {
        return zoneId;
    }

    public static void resetCountingIDS() {
        ZONE_IDS = 0;
        RandProvince.resetCountingIDS();
        RandWaterBody.resetCountingIDS();
    }

    public Point2D getMainPoint() {
        return mainPoint;
    }

    public void setMainPoint(Point2D mainPoint) {
        this.mainPoint = mainPoint;
    }

    public List<Point2D> getBoundary() {
        return boundary;
    }

    public void setBoundary(List<Point2D> boundary) {
        this.boundary = boundary;
    }

    public double getElevation() {
        return elevation;
    }

    public void setElevation(double elevation) {
        this.elevation = elevation;
    }

    public int getProvId() {
        return provId;
    }

    public void setProvId(int provId) {
        this.provId = provId;
    }


    public List<RandWaterBody> getWaterNeighbours() {
        return neighWaters;
    }

    public List<RandProvince> getProvinceNeighbours() {
        return neighProvs;
    }

    // Utility to generate edge key
    private String edgeKey(Point2D a, Point2D b) {
        // Order-independent key (for undirected edge)
        if (a.getX() < b.getX() || (a.getX() == b.getX() && a.getY() <= b.getY())) {
            return a + "-" + b;
        } else {
            return b + "-" + a;
        }
    }

    private Set<String> getEdgeKeys(List<Point2D> boundary) {
        Set<String> edgeSet = new HashSet<>();
        int size = boundary.size();
        for (int i = 0; i < size; i++) {
            Point2D a = boundary.get(i);
            Point2D b = boundary.get((i + 1) % size);
            edgeSet.add(edgeKey(a, b));
        }
        return edgeSet;
    }

    public static void findAndAssignNeighbors(List<GeoPolZone> zones, boolean strict) {
        for (GeoPolZone zoneA : zones) {
            for (GeoPolZone zoneB : zones) {
                if (zoneA == zoneB) continue;

                boolean areNeighbors = strict
                        ? haveSharedEdge(zoneA, zoneB)
                        : haveSharedPoint(zoneA, zoneB);

                if (areNeighbors) {
                    if (zoneA instanceof RandProvince && zoneB instanceof RandProvince) {
                        ((RandProvince) zoneA).neighProvs.add((RandProvince) zoneB);
                    } else if (zoneA instanceof RandProvince && zoneB instanceof RandWaterBody) {
                        ((RandProvince) zoneA).neighWaters.add((RandWaterBody) zoneB);
                    } else if (zoneA instanceof RandWaterBody && zoneB instanceof RandProvince) {
                        ((RandWaterBody) zoneA).neighProvs.add((RandProvince) zoneB);
                    } else if (zoneA instanceof RandWaterBody && zoneB instanceof RandWaterBody) {
                        ((RandWaterBody) zoneA).neighWaters.add((RandWaterBody) zoneB);
                    }
                }
            }
        }
    }

    private static boolean haveSharedEdge(GeoPolZone a, GeoPolZone b) {
        Set<String> edgesA = a.getEdgeKeys(a.getBoundary());
        Set<String> edgesB = b.getEdgeKeys(b.getBoundary());
        for (String edge : edgesA) {
            if (edgesB.contains(edge)) return true;
        }
        return false;
    }

    private static boolean haveSharedPoint(GeoPolZone a, GeoPolZone b) {
        Set<Point2D> pointsA = new HashSet<>(a.getBoundary());
        for (Point2D p : b.getBoundary()) {
            if (pointsA.contains(p)) return true;
        }
        return false;
    }
}
